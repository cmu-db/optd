// Shared properties for logical operators
logical props(schema_len: i64)

scalar ColumnRef(idx: i64)
scalar Const(val: i64)
scalar Eq(left: scalar, right: scalar)
scalar Divide(left: scalar, right: scalar)
scalar Not(input: scalar)

// logical Operators
logical Filter(input: logical, cond: scalar) derive {
  schema_len = input.schema_len
}

logical Project (input: logical, exprs: [scalar]) derive {
  schema_len = exprs.len,
  other = expr2
}

logical Join(
    left: logical,
    right: logical,
    type: String,
    cond: scalar
) derive {
  schema_len = left.schema_len + right.schema_len
}

logical Sort(input: logical, keys: [scalar]) derive {
  schema_len = input.schema_len
}

logical Aggregate(input: logical, group_keys: [scalar], aggs: [scalar]) derive {
  schema_len = group_keys.len + aggs.len
}

// Rules demonstrating all language features
@rule(scalar)
def constant_fold(expr: scalar): scalar =
    match expr
        op @ Add(left: Const(val: x), right: Const(val: y)) => Const(val: x + y),
        op @ Multiply(left: Const(val: x), right: Const(val: y)) => {
            Const(val: x * y)
        },
        And(members: ms) => {
            val folded = ms.map(ms);
            And(members: folded)
        },
        _ => expr

def rewrite_column_refs(expr: scalar, index_map: map[i64 -> i64]): scalar =
    match expr
        ColumnRef(idx: i) => ColumnRef(idx: index_map.get(i)),
        _ => expr.with_children(child => rewrite_column_refs(child, index_map))

@rule(scalar)
def has_refs_in_range(expr: scalar, start: i64, end: i64): Bool =
    match expr {
        ColumnRef(idx: i) => i >= start && i < end,
        _ => expr.children().any(child => has_refs_in_range(child, start, end))
    }

@rule(logical)
def join_commute(expr: logical): logical =
    match expr
        Join(type: "Inner", left: l, right: r, cond: c) => {
            val left_len = l.schema_len;
            val right_len = r.schema_len;
            
            val refs_remap = 
                ((0..left_len).map(i => (i, i + right_len)) ++
                (0..right_len).map(i => (left_len + i, i)))
                .to_map();
            
            Join(
                type: "Inner",
                left: r,
                right: l,
                cond: rewrite_column_refs(c, refs_remap)
            )
        }

@rule(logical)
def join_associate(expr: logical): logical =
    match expr
        Join(
            type: "Inner",
            left: Join(
                type: "Inner",
                left: a,
                right: b,
                cond: c1
            ),
            right: c,
            cond: c2
        ) => {
            val a_len = a.schema_len;
            val b_len = b.schema_len;
            val c_len = c.schema_len;
            if !has_refs_in_range(c2, 0, a_len) then {
                val inner_map = (a_len..(a_len + b_len + c_len))
                    .map(i => (i, i - a_len))
                    .to_map();
                Join(
                    type: "Inner",
                    left: a,
                    right: Join(
                        type: "Inner",
                        left: b,
                        right: c,
                        cond: rewrite_column_refs(c2, inner_map)
                    ),
                    cond: c1
                )
            } else {
                fail("Cannot rewrite: outer join condition references left relation")
            }
        }

@rule(logical)
def complex_project(expr: logical): logical =
    match expr
        project @ Project(input: rel, exprs: es) => {
            if es.len == 0 then
                fail("Empty projection list")
            else {
                val mapped = es.map(e => constant_fold(e));
                val filtered = mapped.filter(e => 
                    match e
                        Const(_) => false,
                        _ => true
                );
                if filtered.len == 0 then
                    fail("All expressions folded to constants")
                else
                    Project(
                        input: rel,
                        exprs: filtered
                    )
            }
        }

@rule(scalar)
def simplify_not(expr: scalar): scalar =
    match expr
        Not(input: Not(input: x)) => x,
        Not(input: Eq(left: l, right: r)) => {
            val new_left = simplify_not(l);
            val new_right = simplify_not(r);
            Not(input: Eq(left: new_left, right: new_right))
        },
        _ => expr

@rule(logical)
def push_filter_down(expr: logical): logical =
    match expr
        Filter(input: Project(input: rel, exprs: es), cond: c) => {
            val new_cond = rewrite_column_refs(c, bla);
            Project(
                input: Filter(input: rel, cond: new_cond),
                exprs: es
            )
        },
        _ => expr

def optimize_sort_keys(expr: logical): logical =
    match expr
        Sort(input: rel, keys: ks) => {
            val simplified = ks.map(k => constant_fold(k));
            val filtered = simplified.filter(k => 
                match k
                    Const(_) => false,
                    _ => true
            );
            Sort(input: rel, keys: filtered)
        },
        _ => expr