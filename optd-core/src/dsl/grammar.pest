WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic identifiers and literals
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Types
operator_type = { "Scalar" | "Logical" }
base_type = { "i64" | "String" | "Bool" | "Float64" }
array_type = { "array" ~ "[" ~ type_expr ~ "]" }
map_type = { "map" ~ "[" ~ type_expr ~ "," ~ type_expr ~ "]" }
tuple_type = { "tuple" ~ "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }
type_expr = { operator_type | base_type | array_type | map_type | tuple_type }

// Annotations
operator_annot = { "@operator" ~ "(" ~ ("scalar" | "logical") ~ ")" }
props_annot = { "@props" ~ "(" ~ "logical" ~ ")" }
derive_props_annot = { "@derive_props" }
rule_annot = { "@rule" ~ "(" ~ ("scalar" | "logical") ~ ")" }

// Operators
operator_def = {
    operator_annot ~ NEWLINE?
    ~ identifier ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (field_def ~ ("," ~ NEWLINE?)*)* ~ NEWLINE?
    ~ derive_props_block?
    ~ "}"
}

field_def = { identifier ~ ":" ~ type_expr }

// Property blocks
props_block = {
    props_annot ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (field_def ~ ("," ~ NEWLINE?)*)* ~ NEWLINE?
    ~ "}"
}

derive_props_block = {
    derive_props_annot ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (prop_derivation | normal_function | expr ~ NEWLINE?)* ~ NEWLINE?
    ~ "}"
}

prop_derivation = { identifier ~ "=" ~ expr }

// Functions
function_def = { normal_function | rule_def }
normal_function = {
    "def" ~ identifier ~ "(" ~ params? ~ ")" ~ ":" ~ type_expr ~ "=" ~ NEWLINE?
    ~ block
}
rule_def = {
    rule_annot ~ NEWLINE?
    ~ normal_function
}

params = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_expr }

// Pattern matching
pattern = {
    identifier ~ "@" ~ constructor_pattern
    | constructor_pattern
    | identifier
    | "_"
}

constructor_pattern = {
    identifier ~ "(" ~ constructor_pattern_fields? ~ ")"
}

constructor_pattern_fields = {
    pattern_field ~ ("," ~ pattern_field)*
}

pattern_field = { identifier ~ ":" ~ pattern }

// Expressions with precedence
expr = { logical_or }
logical_or = { logical_and ~ ("||" ~ logical_and)* }
logical_and = { comparison ~ ("&&" ~ comparison)* }
comparison = { additive ~ (("==" | "!=" | ">=" | "<=" | ">" | "<") ~ additive)* }
additive = { multiplicative ~ (("+" | "-") ~ multiplicative)* }
multiplicative = { postfix ~ (("*" | "/") ~ postfix)* }
postfix = { prefix ~ (call | member_access | array_index)* }
prefix = { ("!" | "-")? ~ primary }

primary = _{
    match_expr
    | if_expr 
    | val_expr
    | array_literal
    | map_literal
    | constructor_expr
    | term
}

term = _{
    number
    | string
    | identifier
    | "(" ~ expr ~ ")"
    | fail_expr
    | closure_expr
}

// Constructor syntax
constructor_expr = {
    identifier ~ "(" ~ constructor_fields? ~ ")"
}

constructor_fields = {
    field_assignment ~ ("," ~ field_assignment)*
}

field_assignment = {
    identifier ~ ":" ~ expr
}

// Other expressions
call = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
member_access = { "." ~ identifier }
array_index = { "[" ~ expr ~ "]" }
array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
map_literal = { "map" ~ "[" ~ expr ~ "]" }
closure_expr = { identifier ~ "=>" ~ expr }
fail_expr = { "fail" ~ "(" ~ string ~ ")" }

// Match expressions
match_expr = {
    "match" ~ expr ~ "{" ~ NEWLINE?
    ~ (match_arm ~ ("," ~ NEWLINE?)*)* ~ NEWLINE?
    ~ "}"
}

match_arm = { pattern ~ "=>" ~ block }
if_expr = { "if" ~ expr ~ block ~ ("else" ~ block)? }
val_expr = { "val" ~ identifier ~ "=" ~ expr }

// Blocks
block = { "{" ~ NEWLINE? ~ (expr ~ NEWLINE?)* ~ "}" }

// Full file
file = {
    SOI ~
    (operator_def | props_block | function_def)* ~
    EOI
}