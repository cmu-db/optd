WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic identifiers and literals
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean = { "true" | "false" }

// Types
operator_type = { "Scalar" | "Logical" }
base_type = { "i64" | "String" | "Bool" | "Float64" }
array_type = { "array" ~ "[" ~ type_expr ~ "]" }
map_type = { "map" ~ "[" ~ type_expr ~ "->" ~ type_expr ~ "]" }
tuple_type = { "tuple" ~ "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }
function_type = { "(" ~ type_expr ~ ")" ~ "->" ~ type_expr }  // Function composition type
type_expr = { operator_type | base_type | array_type | map_type | tuple_type | function_type }

// Annotations
operator_annot = { "@operator" ~ "(" ~ ("scalar" | "logical") ~ ")" }
props_annot = { "@props" ~ "(" ~ "logical" ~ ")" }
rule_annot = { "@rule" ~ "(" ~ ("scalar" | "logical") ~ ")" }

// Operators
operator_def = {
    operator_annot ~ NEWLINE?
    ~ identifier ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (field_def ~ ";" ~ NEWLINE?)*
    ~ derive_props_block?
    ~ "}"
}

field_def = { identifier ~ ":" ~ type_expr }

// Property blocks
props_block = {
    props_annot ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (field_def ~ ";" ~ NEWLINE?)*
    ~ "}"
}

derive_props_block = {
    "derive_props" ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (prop_derivation ~ NEWLINE?)*
    ~ "}"
}

prop_derivation = { identifier ~ "=" ~ expr ~ ";" }

// Functions
function_def = { normal_function | rule_def }
normal_function = {
    "def" ~ identifier ~ "(" ~ params? ~ ")" ~ ":" ~ type_expr ~ "=" ~ NEWLINE?
    ~ block
}
rule_def = {
    rule_annot ~ NEWLINE?
    ~ normal_function
}

params = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_expr }

// Pattern matching
pattern = {
    identifier ~ "@" ~ constructor_pattern
    | constructor_pattern
    | enum_pattern
    | literal_pattern
    | identifier
    | "_"
}

constructor_pattern = {
    identifier ~ "(" ~ constructor_pattern_fields? ~ ")"
}

constructor_pattern_fields = {
    pattern_field ~ ("," ~ pattern_field)*
}

pattern_field = { identifier ~ ":" ~ pattern }

enum_pattern = {
    identifier ~ ("(" ~ pattern ~ ")")? 
}

literal_pattern = {
    number
    | string
    | boolean
    | array_literal
    | tuple_literal
    | map_literal
}

// Expressions with precedence (lowest to highest)
expr = { closure | logical_or }

// Closure is lowest precedence
closure = { closure_params ~ "=>" ~ expr }
closure_params = {
    "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")"
    | identifier  // Single param case
}

logical_or = { logical_and ~ ("||" ~ logical_and)* }
logical_and = { comparison ~ ("&&" ~ comparison)* }
comparison = { concatenation ~ (("==" | "!=" | ">=" | "<=" | ">" | "<") ~ concatenation)* }
concatenation = { additive ~ ("++" ~ additive)* }
additive = { range ~ (("+" | "-") ~ range)* }
range = { multiplicative ~ (".." ~ multiplicative)* }
multiplicative = { postfix ~ (("*" | "/") ~ postfix)* }
postfix = { prefix ~ (call | member_access | array_index | member_call)* }
prefix = { ("!" | "-")? ~ primary }

primary = _{
    match_expr
    | if_expr 
    | val_expr
    | array_literal
    | tuple_literal
    | map_literal
    | constructor_expr
    | term
}

term = _{
    number
    | string
    | boolean
    | identifier
    | "(" ~ expr ~ ")"
    | fail_expr
}

// Constructor syntax
constructor_expr = {
    identifier ~ "(" ~ constructor_fields? ~ ")"
}

constructor_fields = {
    field_assignment ~ ("," ~ field_assignment)*
}

field_assignment = {
    identifier ~ ":" ~ expr
}

// Method calls and operations
call = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
member_access = { "." ~ identifier }
member_call = { "." ~ identifier ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"}
array_index = { "[" ~ expr ~ "]" }

// Array and map literals
array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
tuple_literal = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
map_literal = { "map" ~ "[" ~ expr ~ "]" }

// Control expressions
fail_expr = { "fail" ~ "(" ~ string ~ ")" }

match_expr = {
    "match" ~ expr ~ "{" ~ NEWLINE?
    ~ (match_arm ~ ("," ~ NEWLINE? ~ match_arm)*)? ~ NEWLINE?
    ~ "}"
}

match_arm = { pattern ~ "=>" ~ (block | expr) }
if_expr = { "if" ~ expr ~ block ~ ("else" ~ block)? }
val_expr = { "val" ~ identifier ~ "=" ~ expr ~ ";" ~ expr }

// Blocks
block = { "{" ~ NEWLINE? ~ (expr ~ NEWLINE?)* ~ "}" }

// Full file
file = {
    SOI ~
    (operator_def | props_block | function_def)* ~
    EOI
}