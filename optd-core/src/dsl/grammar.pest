// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic identifiers and literals
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean = { "true" | "false" }

// Types
operator_type = { "scalar" | "logical" }
base_type = { "i64" | "String" | "Bool" | "f64" }
array_type = { "[" ~ type_expr ~ "]" }
map_type = { "map" ~ "[" ~ type_expr ~ "->" ~ type_expr ~ "]" }
tuple_type = { "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }
function_type = { "(" ~ type_expr ~ ")" ~ "->" ~ type_expr }  // Function composition type
type_expr = { operator_type | base_type | array_type | map_type | tuple_type | function_type }

// Annotations
props_annot = { "logical" ~ "props" }
rule_annot = { "@rule" ~ "(" ~ ("scalar" | "logical") ~ ")" }

// Operators
operator_def = {
    operator_type ~ identifier ~ NEWLINE?
    ~ "(" ~ NEWLINE?
    ~ (field_def_list ~ NEWLINE?)?
    ~ ")" 
    ~ (derive_props_block ~ NEWLINE?)?
}

field_def_list = {
    (field_def ~ "," ~ NEWLINE?)* ~ field_def
}

field_def = { identifier ~ ":" ~ type_expr }

// Property blocks
props_block = {
    props_annot ~ NEWLINE?
    ~ "(" ~ NEWLINE?
    ~ (field_def ~ "," ~ NEWLINE?)* ~ field_def
    ~ ")"
}

derive_props_block = {
    "derive" ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (prop_derivation ~ ("," ~ NEWLINE? ~ prop_derivation)*)? ~ NEWLINE?
    ~ "}"
}

prop_derivation = { identifier ~ "=" ~ expr }

// Functions
function_def = { normal_function | rule_def }
normal_function = {
    "def" ~ identifier ~ "(" ~ params? ~ ")" ~ ":" ~ type_expr ~ "=" ~ NEWLINE?
    ~ (expr | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")  // Braces optional
}

rule_def = {
    rule_annot ~ NEWLINE?
    ~ normal_function
}

params = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_expr }

// Pattern matching
pattern = {
    identifier ~ "@" ~ top_level_pattern
    | top_level_pattern
}

top_level_pattern = {
    constructor_pattern
    | enum_pattern
    | literal_pattern
    | identifier
    | "_"
}

constructor_pattern = {
    identifier ~ "(" ~ constructor_pattern_fields? ~ ")"
}

constructor_pattern_fields = {
    pattern_field ~ ("," ~ pattern_field)*
}

pattern_field = { identifier ~ ":" ~ top_level_pattern }

enum_pattern = {
    identifier ~ ("(" ~ top_level_pattern ~ ")")? 
}

literal_pattern = {
    number
    | string
    | boolean
    | array_literal
    | tuple_literal
}

// Expressions with precedence (lowest to highest)
expr = { 
    "{" ~ NEWLINE? ~ (closure | logical_or) ~ NEWLINE? ~ "}"
    | (closure | logical_or)
}

// Closure is lowest precedence
closure = { closure_params ~ "=>" ~ expr }
closure_params = {
    "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")"
    | identifier  // Single param case
}

logical_or = { logical_and ~ ("||" ~ logical_and)* }
logical_and = { comparison ~ ("&&" ~ comparison)* }
comparison = { concatenation ~ (("==" | "!=" | ">=" | "<=" | ">" | "<") ~ concatenation)* }
concatenation = { additive ~ ("++" ~ additive)* }
additive = { range ~ (("+" | "-") ~ range)* }
range = { multiplicative ~ (".." ~ multiplicative)* }
multiplicative = { postfix ~ (("*" | "/") ~ postfix)* }
postfix = { prefix ~ (call | member_access | array_index | member_call)* }
prefix = { ("!" | "-")? ~ primary }

primary = _{
    match_expr
    | if_expr 
    | val_expr
    | array_literal
    | tuple_literal
    | constructor_expr
    | term
}

term = _{
    number
    | string
    | boolean
    | identifier
    | "(" ~ expr ~ ")"
    | fail_expr
}

// Constructor syntax
constructor_expr = {
    identifier ~ "(" ~ constructor_fields? ~ ")"
}

constructor_fields = {
    field_assignment ~ ("," ~ field_assignment)*
}

field_assignment = {
    identifier ~ ":" ~ expr
}

// Method calls and operations
call = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
member_access = { "." ~ identifier }
member_call = { "." ~ identifier ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"}
array_index = { "[" ~ expr ~ "]" }

// Array and map literals
array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
tuple_literal = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

// Control expressions
fail_expr = { "fail" ~ "(" ~ string ~ ")" }

// Braces optional
match_expr = {
    "match" ~ expr ~ NEWLINE?
    ~ (("{" ~ NEWLINE? 
        ~ (match_arm ~ ("," ~ NEWLINE? ~ match_arm)*)? 
        ~ "}")
       | (match_arm ~ ("," ~ NEWLINE? ~ match_arm)*))
    ~ NEWLINE?
}
match_arm = { pattern ~ "=>" ~ expr }

// Braces optional
if_expr = {
    "if" ~ expr ~ NEWLINE?
    ~ (("then" ~ expr) | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")
    ~ "else" ~ NEWLINE?
    ~ (expr | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")
}

val_expr = { "val" ~ identifier ~ "=" ~ expr ~ ";" ~ expr }

// Full file
file = {
    SOI ~
    (operator_def | props_block | function_def)* ~
    EOI
}