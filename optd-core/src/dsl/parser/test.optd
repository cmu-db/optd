// Shared properties for Logical operators
Logical Props(schema_len: Map[(Int64, (Int64) -> String), Int64])

Scalar ColumnRef(idx: (Int64) -> Map[(Int64, (Int64) -> String), Int64])
Scalar Const(asd: Int64)
Scalar Eq(left: Scalar, right: Scalar)
Scalar Divide(left: Scalar, right: Scalar)
Scalar Not(input: Scalar)

// Logical Operators
Logical Filter(input: Logical, cond: Scalar) derive {
  schema_len = input.schema_len
}

Logical Project (input: Logical, exprs: [Scalar]) derive {
  schema_len = exprs.len,
  other = expr2
}

Logical Join(
    left: Logical,
    right: Logical,
    type: String,
    cond: Scalar
) derive {
  schema_len = left.schema_len + right.schema_len
}

Logical Sort(input: Logical, keys: [Scalar]) derive {
  schema_len = input.schema_len
}

Logical Aggregate(input: Logical, group_keys: [Scalar], aggs: [Scalar]) derive {
  schema_len = group_keys.len + aggs.len
}

// Rules demonstrating all language features
@rule(Scalar)
def constant_fold(expr: Scalar): Scalar =
    match expr
        case op @ Add(left: _, Const(bla)) => Const(x + y),
        case op @ Multiply(left: Const(x), right: Const(y)) => {
            Const(x * y)
        },
        case And(ms) => {
            val folded = ms.map(ms);
            val test = (5 + 5) * 3 ++ 87..bla;
            And(folded)
        },
        case _ => expr

def rewrite_column_refs(expr: Scalar, index_map: Map[Int64, Int64]): Scalar =
    match expr
        case ColumnRef(i) => ColumnRef(index_map.get(i)),
        case _ => expr.with_children(child => rewrite_column_refs(child, index_map))

@rule(Scalar)
def has_refs_in_range(expr: Scalar, start: Int64, end: Int64): Bool =
    match expr {
        case ColumnRef(i) => i >= start && i < end,
        case _ => expr.children().any(child => has_refs_in_range(child, start, end))
    }

@rule(Logical)
def join_commute(expr: Logical): Logical =
    match expr
        case Join("Inner", left, right, cond) => {
            val left_len = l.schema_len;
            val right_len = r.schema_len;
            
            val refs_remap = 
                ((0..left_len).map(i => (i, i + right_len)) ++
                (0..right_len).map(i => (left_len + i, i)))
                .to_map();
            
            Join("Inner", r, l, rewrite_column_refs(c, refs_remap))
        }

@rule(Logical)
def join_associate(expr: Logical): Logical =
    match expr
        case Join("Inner", l: Join("Inner", a, b, c1), c, c2) =>
            val a_len = a.schema_len;
            val b_len = b.schema_len;
            val c_len = c.schema_len;
            if !has_refs_in_range(c2, 0, a_len) then
                val inner_map = (a_len..(a_len + b_len + c_len))
                    .map(i => (i, i - a_len))
                    .to_map();
                Join("Inner", a, Join("Inner", b, c, rewrite_column_refs(c2, inner_map)), c1)
            else
                fail("Cannot rewrite: outer join condition references left relation")

@rule(Logical)
def complex_project(expr: Logical): Logical =
    match expr
        case project @ Project(rel, es) => {
            if es.len == 0 then
                fail("Empty projection list")
            else {
                val mapped = es.map(e => constant_fold(e));
                val filtered = mapped.filter(e => 
                    match e
                        case Const(_) => false,
                        case _ => true
                );
                if filtered.len == 0 then
                    fail("All expressions folded to constants")
                else 
                    Project(rel, filtered)
            }
        }

@rule(Scalar)
def simplify_not(expr: Scalar): Scalar =
    match expr
        case Not(Not(x)) => x,
        case Not(Eq(l, r)) => {
            val new_left = simplify_not(l);
            val new_right = simplify_not(r);
            Not(Eq(new_left, new_right))
        },
        case _ => expr

@rule(Logical)
def push_filter_down(expr: Logical): Logical =
    match expr
        case Filter(Project(rel, es), cond) => {
            val new_cond = rewrite_column_refs(cond, bla);
            Project(Filter(rel, new_cond), es)
        },
        case _ => expr

def optimize_sort_keys(expr: Logical): Logical =
    match expr
        case Sort(rel, ks) => {
            val simplified = ks.map(k => constant_fold(k));
            val filtered = simplified.filter(k => 
                match k
                    case Const(_) => false,
                    case _ => true
            );
            Sort(rel, filtered)
        },
        case _ => expr