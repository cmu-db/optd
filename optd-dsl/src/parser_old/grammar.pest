KEYWORD = {
    "Bool" | 
    "Float64" | 
    "Int64" | 
    "Logical" | 
    "Map" | 
    "Props" | 
    "Scalar" | 
    "String" | 
    "case" | 
    "def" | 
    "derive" | 
    "else" | 
    "fail" | 
    "false" | 
    "if" | 
    "match" | 
    "then" | 
    "true" | 
    "val"
}

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic identifiers and literals
identifier = @{ 
    !(KEYWORD ~ !(ASCII_ALPHANUMERIC | "_")) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}
number = @{ "-"? ~ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean = { "true" | "false" }

// Types
operator_type = { "Scalar" | "Logical" }
base_type = { "Int64" | "String" | "Bool" | "Float64" }
array_type = { "[" ~ type_expr ~ "]" }
map_type = { "Map" ~ "[" ~ type_expr ~ "," ~ type_expr ~ "]" }
tuple_type = { "(" ~ type_expr ~ "," ~ type_expr ~ ("," ~ type_expr)* ~ ")" }
function_type = { "(" ~ type_expr ~ ")" ~ "->" ~ type_expr }  // Function composition type
type_expr = { 
    function_type
    | operator_type 
    | base_type 
    | array_type 
    | map_type 
    | tuple_type
}

// Annotations
props_annot = { "Logical" ~ "Props" }
rule_annot = { "@rule" ~ "(" ~ operator_type ~ ")" }

// Operators
operator_def = {
    operator_type ~ identifier ~ NEWLINE?
    ~ "(" ~ NEWLINE?
    ~ (field_def_list ~ NEWLINE?)?
    ~ ")" ~ NEWLINE?
    ~ (derive_props_block ~ NEWLINE?)?
}

field_def_list = {
    (field_def ~ "," ~ NEWLINE?)* ~ field_def
}

field_def = { identifier ~ ":" ~ type_expr }

// Property blocks
props_block = {
    props_annot ~ NEWLINE?
    ~ "(" ~ NEWLINE?
    ~ (field_def ~ "," ~ NEWLINE?)* ~ field_def
    ~ ")"
}

derive_props_block = {
    "derive" ~ NEWLINE?
    ~ "{" ~ NEWLINE?
    ~ (prop_derivation ~ ("," ~ NEWLINE? ~ prop_derivation)*)? ~ NEWLINE?
    ~ "}"
}

prop_derivation = { identifier ~ "=" ~ expr }

// Functions
function_def = { normal_function | rule_def }
normal_function = _{
    "def" ~ identifier ~ "(" ~ params? ~ ")" ~ ":" ~ type_expr ~ "=" ~ NEWLINE?
    ~ (expr | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")  // Braces optional
}

rule_def = _{
    rule_annot ~ NEWLINE?
    ~ normal_function
}

params = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_expr }

// Pattern matching
pattern = {
    (identifier ~ "@" ~ top_level_pattern)
    | top_level_pattern
}

top_level_pattern = _{
    constructor_pattern
    | literal_pattern
    | wildcard_pattern
}

constructor_pattern = {
    identifier ~ "(" ~ constructor_pattern_fields? ~ ")"
}

constructor_pattern_fields = {
    pattern_field ~ ("," ~ pattern_field)*
}

// Inside a constructor
pattern_field = {
    (identifier ~ ":" ~ top_level_pattern) // Bind & match
    | top_level_pattern // Recurse match
    | identifier // Simple bind
}

literal_pattern = {
    number
    | string
    | boolean
    | array_literal
    | tuple_literal
}

wildcard_pattern = { "_" }

// Expressions with precedence (lowest to highest)
expr = { 
    "{" ~ NEWLINE? ~ (closure | logical_or) ~ NEWLINE? ~ "}"
    | (closure | logical_or)
}

// Operators as separate rules
or_op = { "||" }
and_op = { "&&" }
compare_op = { "==" | "!=" | ">=" | "<=" | ">" | "<" }
concat_op = { "++" }
add_op = { "+" | "-" }
range_op = { ".." }
mult_op = { "*" | "/" }

// Closure is lowest precedence
closure = { closure_params ~ "=>" ~ expr }
closure_params = {
    "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")"
    | identifier  // Single param case
}

logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { comparison ~ (and_op ~ comparison)* }
comparison = { concatenation ~ (compare_op ~ concatenation)* }
concatenation = { additive ~ (concat_op ~ additive)* }
additive = { range ~ (add_op ~ range)* }
range = { multiplicative ~ (range_op ~ multiplicative)* }
multiplicative = { postfix ~ (mult_op ~ postfix)* }
postfix = { prefix ~ (member_call | member_access | call | array_index)* }
prefix = { ("!" | "-")? ~ primary }

primary = _{
    match_expr
    | if_expr 
    | val_expr
    | array_literal
    | tuple_literal
    | constructor_expr
    | term
}

term = _{
    number
    | string
    | boolean
    | identifier
    | "(" ~ expr ~ ")"
    | fail_expr
}

// Constructor syntax
constructor_expr = {
    identifier ~ "(" ~ constructor_fields? ~ ")"
}

constructor_fields = _{
    expr ~ ("," ~ expr)*
}

// Method calls and operations
call = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
member_access = { "." ~ identifier }
member_call = { "." ~ identifier ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"}
array_index = { "[" ~ expr ~ "]" }

// Array and map literals
array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
tuple_literal = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

// Control expressions
fail_expr = { "fail" ~ "(" ~ string ~ ")" }

// Braces optional
match_expr = {
    "match" ~ expr ~ NEWLINE?
    ~ (("{" ~ NEWLINE? 
        ~ (match_arm ~ ("," ~ NEWLINE? ~ match_arm)*)? 
        ~ "}")
       | (match_arm ~ ("," ~ NEWLINE? ~ match_arm)*))
    ~ NEWLINE?
}
match_arm = { "case" ~ pattern ~ "=>" ~ expr }

// Braces optional
if_expr = {
    "if" ~ expr ~ NEWLINE?
    ~ (("then" ~ expr) | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")
    ~ "else" ~ NEWLINE?
    ~ (expr | "{" ~ NEWLINE? ~ expr ~ NEWLINE? ~ "}")
}

val_expr = { "val" ~ identifier ~ "=" ~ expr ~ ";" ~ expr }

// Full file
file = {
    SOI ~
    props_block ~
    (operator_def | function_def)* ~
    EOI
}